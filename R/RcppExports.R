# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Buffet procedure for IBP with Gamma mixture from beginning
#' 
#' @param alpha value of alpha in product-form feature allocation
#' @param theta value of theta in product-form feature allocation
#' @param n dimension of the sample to simulate
#' @param a Gamma hyperparameter (shape)
#' @param b Gamma hyperparameter (rate)
#' 
#' @return list: $features contains the simulated features for each customer,
#' $num_new contains the number of new features selected for each customer
#' $counts contains the counts for the observed features
#' 
#' @export
buffet_gamma_IBP <- function(alpha, theta, n, a, b) {
    .Call(`_ProductFormFA_buffet_gamma_IBP`, alpha, theta, n, a, b)
}

#' Buffet procedure for IBP with Gamma mixture given initial sample
#' 
#' @param alpha value of alpha in product-form feature allocation
#' @param theta value of theta in product-form feature allocation
#' @param m dimension of the new sample to be observed
#' @param n dimension of the already observed sample
#' @param counts vector of counts for the already observed features
#' @param a Gamma hyperparameter (shape)
#' @param b Gamma hyperparameter (rate)
#' 
#' @return list: $features contains the simulated features for each customer,
#' $num_new contains the number of new features selected for each customer
#' $counts contains the counts for the observed features
#' 
#' @export
buffet_gamma_IBP_initial_sample <- function(alpha, theta, m, n, counts, a, b) {
    .Call(`_ProductFormFA_buffet_gamma_IBP_initial_sample`, alpha, theta, m, n, counts, a, b)
}

stable_sum_M_all_gamma_IBP <- function(alpha, theta, m, n) {
    .Call(`_ProductFormFA_stable_sum_M_all_gamma_IBP`, alpha, theta, m, n)
}

p_kmn_all_gamma_IBP <- function(alpha, theta, m, n, b) {
    .Call(`_ProductFormFA_p_kmn_all_gamma_IBP`, alpha, theta, m, n, b)
}

p_kmn_gamma_IBP <- function(alpha, theta, m, n, b) {
    .Call(`_ProductFormFA_p_kmn_gamma_IBP`, alpha, theta, m, n, b)
}

#' Negative Log-EFPF for IBP with Gamma mixture with reparametrization
#' 
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#'
#' @param pars pars[0] = value of alpha in product-form feature allocation,
#' pars[1] = value of s = theta+alpha in product-form feature allocation,
#' pars[2] =  value of a - Gamma hyperparameter,
#' pars[3] =  value of b - Gamma hyperparameter
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
neg_log_EFPF_gamma_IBP_rep <- function(n, counts, pars) {
    .Call(`_ProductFormFA_neg_log_EFPF_gamma_IBP_rep`, n, counts, pars)
}

#' Buffet procedure for BB with Negative-Binomial mixture from beginning
#' 
#' @param alpha value of alpha in product-form feature allocation
#' @param theta value of theta in product-form feature allocation
#' @param n dimension of the sample to simulate
#' @param nstar Negative-Binomial hyperparameter (number of successes)
#' @param p Negative-Binomial hyperparameter (success probability)
#' 
#' @return list: $features contains the simulated features for each customer,
#' $num_new contains the number of new features selected for each customer,
#' $counts contains the counts for the observed features
#' 
#' @export
buffet_negbin_BB_wrong <- function(alpha, theta, n, nstar, p) {
    .Call(`_ProductFormFA_buffet_negbin_BB_wrong`, alpha, theta, n, nstar, p)
}

#' Buffet procedure for BB with Negative-Binomial mixture from beginning - correct
#' 
#' @param alpha value of alpha in product-form feature allocation
#' @param theta value of theta in product-form feature allocation
#' @param n dimension of the sample to simulate
#' @param nstar Negative-Binomial hyperparameter (number of successes)
#' @param p Negative-Binomial hyperparameter (success probability)
#' 
#' @return list: $features contains the simulated features for each customer,
#' $num_new contains the number of new features selected for each customer,
#' $counts contains the counts for the observed features
#' 
#' @export
buffet_negbin_BB <- function(alpha, theta, n, nstar, p) {
    .Call(`_ProductFormFA_buffet_negbin_BB`, alpha, theta, n, nstar, p)
}

#' Buffet procedure for BB with Negative-Binomial mixture given initial sample
#' 
#' @param alpha value of alpha in product-form feature allocation
#' @param theta value of theta in product-form feature allocation
#' @param m dimension of the new sample to be observed
#' @param n dimension of the already observed sample
#' @param counts vector of counts for the already observed features
#' @param nstar Negative-Binomial hyperparameter (number of successes)
#' @param p Negative-Binomial hyperparameter (success probability)
#' 
#' @return list: $features contains the simulated features for each customer,
#' $num_new contains the number of new features selected for each customer
#' $counts contains the counts for the observed features
#' 
#' @export
buffet_negbin_BB_initial_sample <- function(alpha, theta, m, n, counts, nstar, p) {
    .Call(`_ProductFormFA_buffet_negbin_BB_initial_sample`, alpha, theta, m, n, counts, nstar, p)
}

p_kmn_all_negbin_BB <- function(alpha, theta, m, n, p) {
    .Call(`_ProductFormFA_p_kmn_all_negbin_BB`, alpha, theta, m, n, p)
}

p_kmn_negbin_BB <- function(alpha, theta, m, n, p) {
    .Call(`_ProductFormFA_p_kmn_negbin_BB`, alpha, theta, m, n, p)
}

#' 
#' @param pars vector of parameters to optimize
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#' @param nopt_par vector of parameters not to optimize
#' @param opt boolean vector indicating if the variable is optimized
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
#' @export 
neg_log_EFPF_negbin_BB <- function(pars, n, counts, nopt_par, opt) {
    .Call(`_ProductFormFA_neg_log_EFPF_negbin_BB`, pars, n, counts, nopt_par, opt)
}

#' 
#' @param pars vector of parameters to optimize
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#' @param nopt_par vector of parameters not to optimize
#' @param opt boolean vector indicating if the variable is optimized
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
#' @export 
neg_log_EFPF_negbin_BB_rep <- function(pars, n, counts, nopt_par, opt) {
    .Call(`_ProductFormFA_neg_log_EFPF_negbin_BB_rep`, pars, n, counts, nopt_par, opt)
}

#' (when all the parameters are optimized)
#' 
#' @param pars vector of parameters to optimize
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
#' @export 
neg_log_EFPF_negbin_BB_rep_all <- function(pars, n, counts) {
    .Call(`_ProductFormFA_neg_log_EFPF_negbin_BB_rep_all`, pars, n, counts)
}

#' Negative Log-EFPF for BB with Negative-Binomial mixture NO reparametrization -
#' - (mean-variance parametrization)
#' 
#' @param pars vector of parameters to optimize
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#' @param nopt_par vector of parameters not to optimize
#' @param opt boolean vector indicating if the variable is optimized
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
#' @export 
neg_log_EFPF_negbin_mv_BB <- function(pars, n, counts, nopt_par, opt) {
    .Call(`_ProductFormFA_neg_log_EFPF_negbin_mv_BB`, pars, n, counts, nopt_par, opt)
}

#' Negative Log-EFPF for BB with Negative-Binomial mixture with reparametrization
#' (and mean-variance parametrization)
#' 
#' @param pars vector of parameters to optimize
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#' @param nopt_par vector of parameters not to optimize
#' @param opt boolean vector indicating if the variable is optimized
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
#' @export 
neg_log_EFPF_negbin_mv_BB_rep <- function(pars, n, counts, nopt_par, opt) {
    .Call(`_ProductFormFA_neg_log_EFPF_negbin_mv_BB_rep`, pars, n, counts, nopt_par, opt)
}

#' (when all the parameters are optimized -  mean-variance parametrization)
#' 
#' @param pars vector of parameters to optimize
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
#' @export 
neg_log_EFPF_negbin_mv_BB_rep_all <- function(pars, n, counts) {
    .Call(`_ProductFormFA_neg_log_EFPF_negbin_mv_BB_rep_all`, pars, n, counts)
}

#' Buffet procedure for BB with Poisson mixture from beginning
#' 
#' @param alpha value of alpha in product-form feature allocation
#' @param theta value of theta in product-form feature allocation
#' @param n dimension of the sample to simulate
#' @param lambda Poisson hyperparameter 
#' 
#' @return list: $features contains the simulated features for each customer,
#' $num_new contains the number of new features selected for each customer
#' $counts contains the counts for the observed features
#' 
#' @export
buffet_poiss_BB <- function(alpha, theta, n, lambda) {
    .Call(`_ProductFormFA_buffet_poiss_BB`, alpha, theta, n, lambda)
}

#' Buffet procedure for BB with Poisson mixture given initial sample
#' 
#' @param alpha value of alpha in product-form feature allocation
#' @param theta value of theta in product-form feature allocation
#' @param m dimension of the new sample to be observed
#' @param n dimension of the already observed sample
#' @param counts vector of counts for the already observed features
#' @param lambda Poisson hyperparameter
#' 
#' @return list: $features contains the simulated features for each customer,
#' $num_new contains the number of new features selected for each customer
#' $counts contains the counts for the observed features
#' 
#' @export
buffet_poiss_BB_initial_sample <- function(alpha, theta, m, n, counts, lambda) {
    .Call(`_ProductFormFA_buffet_poiss_BB_initial_sample`, alpha, theta, m, n, counts, lambda)
}

mean_kmn_all_poiss_BB <- function(alpha, theta, m, n, lambda) {
    .Call(`_ProductFormFA_mean_kmn_all_poiss_BB`, alpha, theta, m, n, lambda)
}

#' @export
mean_kmn_poiss_BB <- function(alpha, theta, m, n, lambda) {
    .Call(`_ProductFormFA_mean_kmn_poiss_BB`, alpha, theta, m, n, lambda)
}

#' Negative Log-EFPF for BB with Poisson mixture with reparametrization
#' 
#' @param n dimension of the observed sample
#' @param counts vector of cardinalities for the observed features
#'
#' @param pars pars[0] = value of alpha in product-form feature allocation,
#' pars[1] = value of s = theta+alpha in product-form feature allocation,
#' pars[2] =  value of lambda - Poisson hyperparameter
#' 
#' @return value of the negative logarithm of the EFPF for the sample of 
#' dimensionality n described by counts
#' 
neg_log_EFPF_poiss_BB_rep <- function(n, counts, pars) {
    .Call(`_ProductFormFA_neg_log_EFPF_poiss_BB_rep`, n, counts, pars)
}

cpp_rbern <- function(n, prob) {
    .Call(`_ProductFormFA_cpp_rbern`, n, prob)
}

